###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.1.7746/W32 for ARM        09/Feb/2015  18:57:26
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server\src\BLE_Chat_main.c
#    Command line =  
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server\src\BLE_Chat_main.c" -D
#        USE_STDPERIPH_DRIVER -D STM32L1XX_MD -D SYSCLK_FREQ_HSI_32MHz -D
#        ENABLE_USB -D ENABLE_USB_PRINTF -D SERVER=1 -lcN
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server\EWARM\Server\List\"
#        --diag_suppress Pa050 -o "C:\Users\Matthew\Documents\2014 -
#        2015\Senior Project\Bluetooth code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\Obj\" --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server\EWARM\..\inc\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects V2\Project\BLE_Chat_Server\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\" -I "C:\Users\Matthew\Documents\2014 -
#        2015\Senior Project\Bluetooth code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\Bluetooth
#        LE\SimpleBlueNRG_HCI\includes\" -I "C:\Users\Matthew\Documents\2014 -
#        2015\Senior Project\Bluetooth code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\" -I
#        "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32L1xx\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32_USB-FS-Device_Driver\inc\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\STM32L1xx_StdPeriph_Driver\inc\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\I2C\inc\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\LIS3DH\inc\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\STLM75\inc\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\HTS221\inc\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\LPS25H\inc\"
#        -I "C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\..\..\..\platform\STM32L1XX\Libraries\SDK_Eval_STM32L\inc\"
#        -Ohs --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\List\BLE_Chat_main.lst
#    Object file  =  
#        C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth
#        code\Projects
#        V2\Project\BLE_Chat_Server\EWARM\Server\Obj\BLE_Chat_main.o
#
###############################################################################

C:\Users\Matthew\Documents\2014 - 2015\Senior Project\Bluetooth code\Projects V2\Project\BLE_Chat_Server\src\BLE_Chat_main.c
      1          /******************** (C) COPYRIGHT 2014 STMicroelectronics ********************
      2          * File Name          : BLE_Chat_main.c
      3          * Author             : AMS - AAS Division
      4          * Version            : V1.0.1
      5          * Date               : 10-February-2014
      6          * Description        : BlueNRG main file for Chat demo
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          /**
     16           * @file  BLE_Chat_main.c
     17           * @brief This is a Chat demo that shows how to implement a simple 2-way communication between two BlueNRG devices.
     18           *
     19           * <!-- Copyright 2014 by STMicroelectronics.  All rights reserved.       *80*-->
     20          
     21          * \section IAR_project IAR project
     22            To use the project with IAR Embedded Workbench for ARM, please follow the instructions below:
     23            -# Open the Embedded Workbench for ARM.
     24            -# From the File->Open->Workspace menu, open the IAR workspace
     25               <tt> ...\\Projects\\Project\\BLE_Chat\\EWARM\\BLE_Chat.eww </tt>
     26            -# Select desired configuration to build
     27            -# Select Project->Rebuild All. This will recompile and link the entire application
     28            -# To download the binary image, please connect STLink to JTAG connector  in your board (if available).
     29            -# Select Project->Download and Debug to download the related binary image.
     30            -# Alternatively, open the BlueNRG GUI, put the board in DFU mode and download the built binary image.
     31            -# Connect the application board to a PC USB port. Open a hyperterminal on the
     32               corresponding USB virtual COMx port with the configuration as described in \ref Serial_IO.
     33          
     34          * \subsection IAR_project_configurations IAR project configurations
     35          
     36            - \c Client - Client role configuration 
     37            - \c Server - Server role configuration
     38            - \c Client_throughput - Client role configuration for throughput test
     39            - \c Server_throughput - Server role configuration for throughput test
     40          
     41          * \section Prebuilt_images Prebuilt images
     42            - BLE_Chat_Client.hex, BLE_Chat_Server.hex 
     43           
     44          * \section Jumper_settings Jumper settings
     45          @table
     46          ------------------------------------------------------
     47          | Jumper name       |  Description                   | 
     48          ------------------------------------------------------
     49          | JP1, if available | USB or Battery supply position | 
     50          
     51          @endtable 
     52          
     53          
     54          * \section Board_supported Board supported
     55          @table
     56          | Board name      | Board revision | NOTE        |
     57          --------------------------------------------------
     58          | STEVAL-IDB002V1 | 3.0            | Eval Kit    |
     59          | STEVAL-IDB003V1 | 1.0            | USB Dongle  |
     60          @endtable
     61          
     62          * \section Serial_IO Serial I/O
     63            The application will listen for keys typed in one node and, on return press, it will send them to the remote node.
     64            The remote node will listen for RF messages and it will output them in the serial port.
     65            In other words everything typed in one node will be visible to the other node and viceversa.
     66          @table
     67          | Parameter name  | Value          | Unit        |
     68          --------------------------------------------------
     69          | Baudrate        | 115200         | bit/sec     |
     70          | Data bits       | 8              | bit         |
     71          | Parity          | None           | bit         |
     72          | Stop bits       | 1              | bit         |
     73          @endtable
     74          
     75          * \section LEDs_description LEDs description
     76          @table
     77          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     78          | LED name         | Client/Server   | Client/Server   | 
     79          --------------------------------------------------------
     80          | D1               | Not used        | NA              |        
     81          | D2               | Not used        | Not used        |     
     82          | D3               | Not used        | Not used        |     
     83          | D4               | Not used        | NA              |      
     84          | D5               | Not used        | NA              |       
     85          | D6               | Not used        | NA              |       
     86          @endtable
     87           - NA : Not Applicable;
     88          
     89          * \section Buttons_description Buttons description
     90          @table
     91          |                  | STEVAL-IDB002V1 | STEVAL-IDB003V1 |                 
     92          | Button name      | Client/Server   | Client/Server   | 
     93          --------------------------------------------------------
     94          | RESET            | X               | NA              |  
     95          | Push Button      | Not used        | NA              |   
     96          | Jostick Sel      | Not used        | NA              |    
     97          | SW1              | NA              | Not used        |     
     98          | SW2              | NA              | Not used        |       
     99          @endtable
    100           - NA : Not Applicable;
    101          
    102          * \section DFU_Activation  DFU activation
    103          BlueNRG boards are preprogrammed with a DFU application which allows to upload the 
    104          STM32L micro with a selected binary image through USB. Follow list of actions 
    105          for activating DFU on each supported platforms
    106          @table
    107          | Board  name          | Event                                             | Note               |
    108          ------------------------------------------------------------------------------------------------|
    109          | STEVAL-IDB002V1      | Press RESET and Push Button. Release RESET button | LED D2 is toggling |  
    110          | STEVAL-IDB003V1      | Press SW1 button and plug USB dongle on a PC port | LED D3 is toggling |  
    111          @endtable
    112          
    113          * \section Usage Usage
    114          
    115          This Chat demo has  are 2 roles:
    116           - The server that expose the Chat service. It is the slave.
    117           - The client that uses the Chat service. It is the master.
    118          
    119          The Chat Service contains 2 Characteristics:
    120           -# The TX Characteristic: the client can enable notifications on this characteristic. When the server has data to be sent, it will send notifications which will contains the value of the TX Characteristic
    121           -# The RX Characteristic: it is a writable caracteristic. When the client has data to be sent to the server, it will write a value into this characteristic.
    122          
    123          The maximum length of the characteristic value is 20 bytes.
    124          
    125          NOTES:
    126           - The Client_throughput and Server_throughput workspaces allow to target a throughput test (THROUGHPUT_TEST define on the preprocessor options on both workspaces).
    127           - Program the client on one BlueNRG platform and reset it. The platform will be seen on the PC as a virtual COM port. Open the port in a serial terminal emulator. Client will start 4 seconds after reset.
    128           - Program the server on a second BlueNRG platform and reset it. The two platforms will try to establish a connection. As soon as they get connected, the slave will 
    129             send notification to the client of 20 bytes (200 notifications). 
    130           - After all the notifications are received, the measured application throughput will be displayed.
    131          
    132          **/
    133          /** @addtogroup BlueNRG_demonstrations_applications
    134           * BlueNRG Chat demo \see BLE_Chat_main.c for documentation.
    135           *
    136           *@{
    137           */
    138          
    139          /** @} */
    140          /** \cond DOXYGEN_SHOULD_SKIP_THIS
    141           */
    142          /* Includes ------------------------------------------------------------------*/
    143          #include "stm32l1xx.h"
    144          #include "usb_lib.h"
    145          #include "hw_config.h"
    146          #include "hal_types.h"
    147          #include "hci.h"
    148          #include "bluenrg_aci.h"
    149          #include "gp_timer.h"
    150          #include "hal.h"
    151          #include "osal.h"
    152          #include "gatt_db.h"
    153          #include "gatt_server.h"
    154          #include "hci_const.h"
    155          #include "gap.h"
    156          #include "sm.h"
    157          #include "app_state.h"
    158          #include "led.h"
    159          #include "push_button.h"
    160          #include "timer.h"
    161          #include <stdio.h>
    162          
    163          #include "SDK_EVAL_Config.h"
    164          
    165          /* External variables --------------------------------------------------------*/
    166          /* Private typedef -----------------------------------------------------------*/
    167          /* Private defines -----------------------------------------------------------*/
    168          /** 
    169            * @brief  Enable debug printf's
    170            */ 
    171          #ifndef DEBUG
    172          #define DEBUG 1
    173          #endif
    174                
    175          #define REQUEST_CONN_PARAM_UPDATE 0
    176          
    177          /* Private macros ------------------------------------------------------------*/
    178          #if DEBUG
    179          #include <stdio.h>
    180          #define PRINTF(...) printf(__VA_ARGS__)
    181          #else
    182          #define PRINTF(...)
    183          #endif
    184          
    185          #define NUM_PACKETS 200 // Only used for throughput test (define THROUGHPUT_TEST)
    186          
    187          #ifndef VECTOR_TABLE_BASE_ADDRESS 
    188          /* default configuration: DFU upgrade is supported */
    189          #define VECTOR_TABLE_BASE_ADDRESS            (0x3000)
    190          #endif
    191          
    192          /* Private variables ---------------------------------------------------------*/
    193          volatile int app_flags = SET_CONNECTABLE;
    194          volatile uint16_t connection_handle = 0;
    195          extern uint16_t chatServHandle, TXCharHandle, RXCharHandle;
    196          struct timer l2cap_req_timer;
    197          //volatile int numConnected = 0;
    198          
    199          /** 
    200            * @brief  Handle of TX,RX  Characteristics.
    201            */ 
    202          #ifdef CLIENT
    203          uint16_t tx_handle;
    204          uint16_t rx_handle;
    205          #endif 
    206          
    207          
    208          /* Private function prototypes -----------------------------------------------*/
    209          void Make_Connection(void);
    210          void User_Process(void);
    211          
    212          /* Private functions ---------------------------------------------------------*/
    213          
    214          /*  User Function where serial received data should be processed */
    215          void processInputData(uint8_t * rx_data, uint16_t data_size);
    216          
    217          /*******************************************************************************
    218          * Function Name  : main.
    219          * Description    : Main routine.
    220          * Input          : None.
    221          * Output         : None.
    222          * Return         : None.
    223          *******************************************************************************/
    224          int main(void)
    225          {
    226              int ret;
    227              
    228              NVIC_SetVectorTable(NVIC_VectTab_FLASH, VECTOR_TABLE_BASE_ADDRESS);
    229              
    230              /* Identify BlueNRG platform */
    231              SdkEvalIdentification();
    232          
    233              RCC_Configuration();
    234              
    235              /* Init I/O ports */
    236              Init_GPIOs ();
    237              
    238              PWR_PVDCmd(DISABLE);
    239              
    240              /* Initialize LEDs */
    241              initLED(0);
    242              initLED(3);
    243              initLED(4);
    244              
    245              /* Initilize event */
    246              initTimer(2,1000);
    247              enableTimerInterrupt(2);
    248              initTimer(4,100);
    249              enableTimerInterrupt(4);
    250              initTimer(6,5000);
    251              enableTimerInterrupt(6);
    252              
    253              
    254              /* Disable FLASH during Sleep  */
    255              FLASH_SLEEPPowerDownCmd(ENABLE);
    256              
    257              /* Enable Ultra low power mode */
    258              PWR_UltraLowPowerCmd(ENABLE);
    259              
    260              PWR_FastWakeUpCmd(ENABLE);
    261              
    262              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    263              
    264              Clock_Init();
    265              
    266              /* Delay needed only to be able to acces the JTAG interface after reset
    267              if it will be disabled later. */
    268              Clock_Wait(500);    
    269              
    270              /* Configure I/O communication channel:
    271                 It requires the void IO_Receive_Data(uint8_t * rx_data, uint16_t data_size) function
    272                 where user received data should be processed */
    273              SdkEval_IO_Config(processInputData);
    274              
    275              /* Delay for debug purpose, in order to see printed data at startup. */
    276              for(int i = 0; i < 100 ; i++){
    277                  printf(".");
    278                  Clock_Wait(70);
    279              }
    280          
    281              HCI_Init();
    282              
    283              /* Init SPI interface */
    284              SdkEvalSpiInit(SPI_MODE_EXTI);
    285              BlueNRG_RST(); 
    286              
    287              {
    288          #if CLIENT
    289                  uint8_t bdaddr[] = {0xbb, 0x00, 0x00, 0xE1, 0x80, 0x02};
    290          #else
    291                  uint8_t bdaddr[] = {0xaa, 0x00, 0x00, 0xE1, 0x80, 0x02};
    292          #endif
    293                  ret = aci_hal_write_config_data(CONFIG_DATA_PUBADDR_OFFSET, CONFIG_DATA_PUBADDR_LEN,
    294                                                  bdaddr);
    295                  if(ret){
    296                      PRINTF("Setting BD_ADDR failed.\n");
    297                  }
    298              }
    299              
    300              ret = aci_gatt_init();    
    301              if(ret){
    302                  PRINTF("GATT_Init failed.\n");
    303              }
    304              
    305              {
    306                  uint16_t service_handle, dev_name_char_handle, appearance_char_handle;
    307          #if SERVER
    308                  ret = aci_gap_init(GAP_PERIPHERAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);
    309          #else
    310                  ret = aci_gap_init(GAP_CENTRAL_ROLE, &service_handle, &dev_name_char_handle, &appearance_char_handle);
    311          #endif
    312                  if(ret){
    313                      PRINTF("GAP_Init failed.\n");
    314                  }
    315              }
    316            
    317              /*ret = aci_gap_set_auth_requirement(MITM_PROTECTION_REQUIRED,
    318                                                 OOB_AUTH_DATA_ABSENT,
    319                                                 NULL,
    320                                                 7,
    321                                                 16,
    322                                                 USE_FIXED_PIN_FOR_PAIRING,       //*************************************
    323                                                 123456,
    324                                                 BONDING);
    325              PRINTF("BLE Stack Initialized.\r\n");*/
    326              
    327          #if  SERVER
    328              PRINTF("SERVER: BLE Stack Initialized (platform: %d)\n\r", SdkEvalGetVersion());
    329              ret = Add_Chat_Service();
    330              
    331              if(ret == BLE_STATUS_SUCCESS)
    332                  PRINTF("Service added successfully.\r\n");
    333              else
    334                  PRINTF("Error while adding service.\r\n");
    335              
    336          #else
    337              PRINTF("CLIENT: BLE Stack Initialized  (platform: %d)\n\r", SdkEvalGetVersion());
    338          #endif 
    339              
    340              /* -2 dBm output power */
    341              ret = aci_hal_set_tx_power_level(1,4);
    342                  
    343              while(1)
    344              { 
    345                  HCI_Process();
    346                  User_Process();
    347                  //Clock_Wait(10000);
    348              }
    349          }
    350          
    351          /**
    352            * @brief  Make the device connectable
    353            * @param  None 
    354            * @retval None
    355            */
    356          void Make_Connection(void)
    357          {  
    358              tBleStatus ret;
    359              
    360              
    361          #if CLIENT
    362              tBDAddr bdaddr = {0xaa, 0x00, 0x00, 0xE1, 0x80, 0x02};
    363              
    364              //ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, bdaddr, PUBLIC_ADDR, 40, 40, 0, 60, 2000 , 2000); 
    365              ret = aci_gap_create_connection(0x4000, 0x4000, PUBLIC_ADDR, bdaddr, PUBLIC_ADDR, 9, 9, 0, 60, 1000 , 1000); 
    366              if (ret != 0){
    367                  PRINTF("Error while starting connection.\n");
    368                  Clock_Wait(100);        
    369          	}
    370          #else
    371              
    372              const char local_name[] = {AD_TYPE_COMPLETE_LOCAL_NAME,'B','l','u','e','N','R','G','_','C','h','a','t'};
    373              
    374              /* disable scan response */
    375              //hci_le_set_scan_resp_data(0,NULL);
    376              
    377              PRINTF("General Discoverable Mode ");
    378              ret = aci_gap_set_discoverable(ADV_IND, 0x00a0, 0x00a0, PUBLIC_ADDR, 0x00,
    379                                             13, local_name, 0, 0x0, 0, 0);
    380          
    381              PRINTF("%d\n\r",ret);
    382          #endif
    383          }
    384          
    385          /**
    386            * @brief  This function is called when there is a LE Connection Complete event.
    387            * @param  addr Address of peer device
    388            * @param  handle Connection handle
    389            * @retval None
    390            */
    391          void GAP_ConnectionComplete_CB(uint8_t addr[6], uint16_t handle)
    392          {    
    393              APP_FLAG_SET(CONNECTED); 
    394              connection_handle = handle;
    395              
    396              //Show connection with LED
    397              turnLED(3,ON);
    398              //numConnected += 1;
    399              //if(numConnected != 2)
    400                //APP_FLAG_SET(SET_CONNECTABLE);
    401              
    402              PRINTF("Connected to device:");
    403              for(int i = 5; i > 0; i--){
    404                  PRINTF("%02X-", addr[i]);
    405              }
    406              PRINTF("%02X\n\r", addr[0]);
    407              
    408          #if REQUEST_CONN_PARAM_UPDATE
    409              APP_FLAG_CLEAR(L2CAP_PARAM_UPD_SENT);
    410              Timer_Set(&l2cap_req_timer, CLOCK_SECOND*2);
    411          #endif
    412              
    413          }
    414          
    415          /**
    416            * @brief  This function is called when the peer device get disconnected.
    417            * @param  None 
    418            * @retval None
    419            */
    420          void GAP_DisconnectionComplete_CB(void)
    421          {
    422            //Turn off connection LED
    423            turnLED(3,OFF);
    424            //numConnected -+ 1;
    425              APP_FLAG_CLEAR(CONNECTED);
    426              PRINTF("Disconnected\n\r");
    427              /* Make the device connectable again. */
    428              APP_FLAG_SET(SET_CONNECTABLE);
    429              APP_FLAG_CLEAR(NOTIFICATIONS_ENABLED);
    430              
    431              APP_FLAG_CLEAR(START_READ_TX_CHAR_HANDLE);
    432              APP_FLAG_CLEAR(END_READ_TX_CHAR_HANDLE);
    433              APP_FLAG_CLEAR(START_READ_RX_CHAR_HANDLE); 
    434              APP_FLAG_CLEAR(END_READ_RX_CHAR_HANDLE); 
    435          }
    436          
    437          /**
    438            * @brief  This function is called when there is a notification from the sever.
    439            * @param  attr_handle Handle of the attribute
    440            * @param  attr_len    Length of attribute value in the notification
    441            * @param  attr_value  Attribute value in the notification
    442            * @retval None
    443            */
    444          void GATT_Notification_CB(uint16_t attr_handle, uint8_t attr_len, uint8_t *attr_value)
    445          {
    446          #if THROUGHPUT_TEST && CLIENT
    447              static tClockTime time, time2;
    448              static int packets=0;     
    449              
    450              if(attr_handle == tx_handle+1){ 
    451                  if(packets==0){
    452                      printf("Test start\n\r");
    453                      time = Clock_Time();
    454                  }
    455                  
    456                  for(int i = 0; i < attr_len; i++)
    457                      printf("%c", attr_value[i]);
    458                  
    459                  printf("[RX: %d]", packets);//TBR
    460                  
    461                  packets++;
    462                  
    463                  if(packets == NUM_PACKETS){
    464                      time2 = Clock_Time();
    465                      tClockTime diff = time2-time;
    466                      printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    467                  }        
    468                  
    469              }
    470          #elif CLIENT
    471              
    472              if(attr_handle == tx_handle+1){
    473                for(int i = 0; i < attr_len; i++)
    474                    printf("%c", attr_value[i]);
    475              }
    476          #endif
    477          }
    478          
    479          void User_Process(void)
    480          {
    481              if(APP_FLAG(SET_CONNECTABLE)){
    482                  Make_Connection();
    483                  APP_FLAG_CLEAR(SET_CONNECTABLE);
    484              }
    485          
    486          #if REQUEST_CONN_PARAM_UPDATE    
    487              if(APP_FLAG(CONNECTED) && !APP_FLAG(L2CAP_PARAM_UPD_SENT) && Timer_Expired(&l2cap_req_timer)){
    488                  aci_l2cap_connection_parameter_update_request(connection_handle, 8, 16, 0, 600);
    489                  APP_FLAG_SET(L2CAP_PARAM_UPD_SENT);
    490              }
    491          #endif
    492              
    493          #if CLIENT
    494              
    495              
    496              /* Start TX handle Characteristic discovery if not yet done */
    497              if (APP_FLAG(CONNECTED) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    498              {
    499                if (!APP_FLAG(START_READ_TX_CHAR_HANDLE))
    500                {
    501                  /* Discovery TX characteristic handle by UUID 128 bits */
    502                  
    503                   const uint8_t charUuid128_TX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe1,0xf2,0x73,0xd9};
    504                   
    505                   aci_gatt_disc_charac_by_uuid(connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    506                                                             charUuid128_TX);
    507                   APP_FLAG_SET(START_READ_TX_CHAR_HANDLE);
    508                }
    509              }
    510              /* Start RX handle Characteristic discovery if not yet done */
    511              else if (APP_FLAG(CONNECTED) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    512              {
    513                /* Discovery RX characteristic handle by UUID 128 bits */
    514                if (!APP_FLAG(START_READ_RX_CHAR_HANDLE))
    515                {
    516                  /* Discovery TX characteristic handle by UUID 128 bits */
    517                  
    518                   const uint8_t charUuid128_RX[16] = {0x66,0x9a,0x0c,0x20,0x00,0x08,0x96,0x9e,0xe2,0x11,0x9e,0xb1,0xe2,0xf2,0x73,0xd9};
    519                   aci_gatt_disc_charac_by_uuid(connection_handle, 0x0001, 0xFFFF,UUID_TYPE_128,
    520                                                             charUuid128_RX);
    521                   APP_FLAG_SET(START_READ_RX_CHAR_HANDLE);
    522                 }
    523              }
    524              
    525              if(APP_FLAG(CONNECTED) && APP_FLAG(END_READ_TX_CHAR_HANDLE) && APP_FLAG(END_READ_RX_CHAR_HANDLE) && !APP_FLAG(NOTIFICATIONS_ENABLED)){
    526                  uint8_t client_char_conf_data[] = {0x01, 0x00}; // Enable notifications
    527                  struct timer t;
    528                  Timer_Set(&t, CLOCK_SECOND*10);
    529                  
    530                  while(aci_gatt_write_charac_descriptor(connection_handle, tx_handle+2, 2, client_char_conf_data)==BLE_STATUS_NOT_ALLOWED){ //TX_HANDLE;
    531                      // Radio is busy.
    532                      if(Timer_Expired(&t)) break;
    533                  }
    534                  APP_FLAG_SET(NOTIFICATIONS_ENABLED);
    535                }
    536              else if(APP_FLAG(CONNECTED) && APP_FLAG(END_READ_TX_CHAR_HANDLE) && APP_FLAG(END_READ_RX_CHAR_HANDLE) && APP_FLAG(NOTIFICATIONS_ENABLED)){
    537                uint8_t data_buffer[] = {0x48,0x45,0x4c,0x4c,0x4f,0x0d};
    538                uint16_t Nb_bytes = 6;
    539                processInputData(data_buffer, Nb_bytes);
    540                Clock_Wait(1000);
    541                }
    542             
    543          #endif
    544              
    545              
    546          #if THROUGHPUT_TEST && SERVER
    547              
    548              
    549              static uint8_t test_done = FALSE;
    550              
    551              if(APP_FLAG(CONNECTED) && !test_done && APP_FLAG(NOTIFICATIONS_ENABLED)){
    552              
    553                  uint8_t data[20] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J'};
    554                  
    555                  static tClockTime time, time2;
    556                  time = Clock_Time();
    557                  
    558                  for(int i = 0; i < NUM_PACKETS; i++){
    559                      
    560                      struct timer t;
    561                      Timer_Set(&t, CLOCK_SECOND*10);
    562                                      
    563                      while(aci_gatt_update_char_value(chatServHandle, TXCharHandle, 0, 20, data)==BLE_STATUS_INSUFFICIENT_RESOURCES)
    564                      {
    565                        // Radio is busy (buffer full).
    566                        if(Timer_Expired(&t))
    567                            break;
    568                      }
    569                  
    570                  }
    571                  
    572                  time2 = Clock_Time();
    573                  tClockTime diff = time2-time;
    574                  printf("\n%d packets. Elapsed time: %d ms. App throughput: %.2f kbps.\n\r", NUM_PACKETS, diff, (float)NUM_PACKETS*20*8/diff);
    575                  
    576                  test_done = TRUE;
    577              }
    578          #endif
    579              
    580          }
    581          
    582          /**
    583            * @brief  This function is called whenever there is an ACI event to be processed.
    584            * @note   Inside this function each event must be identified and correctly
    585            *         parsed.
    586            * @param  pckt  Pointer to the ACI packet
    587            * @retval None
    588            */
    589          void HCI_Event_CB(void *pckt)
    590          {
    591              hci_uart_pckt *hci_pckt = pckt;
    592              hci_event_pckt *event_pckt = (hci_event_pckt*)hci_pckt->data;
    593              
    594              if(hci_pckt->type != HCI_EVENT_PKT)
    595                  return;
    596              
    597              switch(event_pckt->evt){
    598                  
    599              case EVT_DISCONN_COMPLETE:
    600                  {
    601                      GAP_DisconnectionComplete_CB();
    602                  }
    603                  break;
    604                  
    605              case EVT_LE_META_EVENT:
    606                  {
    607                      evt_le_meta_event *evt = (void *)event_pckt->data;
    608                      
    609                      switch(evt->subevent){
    610                      case EVT_LE_CONN_COMPLETE:
    611                          {
    612                              evt_le_connection_complete *cc = (void *)evt->data;
    613                              GAP_ConnectionComplete_CB(cc->peer_bdaddr, cc->handle);
    614                          }
    615                          break;
    616                      }
    617                  }
    618                  break;
    619                  
    620              case EVT_VENDOR:
    621                  {
    622                      evt_blue_aci *blue_evt = (void*)event_pckt->data;
    623                      switch(blue_evt->ecode){
    624                          
    625                      case EVT_BLUE_GATT_ATTRIBUTE_MODIFIED:
    626                          {
    627                              evt_gatt_attr_modified *evt = (evt_gatt_attr_modified*)blue_evt->data;
    628                              Attribute_Modified_CB(evt->attr_handle, evt->data_length, evt->att_data);
    629                              
    630                              //Catch event
    631                              GPIO_ToggleBits(GPIOC,LED0);
    632                              uint16_t defined_hex = 0x45;
    633                              uint16_t handle = evt->attr_handle;
    634                              uint8_t data_length = evt->data_length;
    635                              uint8_t *att_data = evt->att_data;
    636                              if(handle == RXCharHandle + 1){
    637                                if(att_data[0] == defined_hex){
    638                                  // call function
    639                                   startTimer(2);
    640                                 }
    641                                 //Clock_Wait(100);
    642                                 //att_data[0] = att_data[0]+1;
    643                                 //processInputData(att_data, data_length);
    644                              }
    645                              
    646                          }
    647                          break;
    648                      case EVT_BLUE_GATT_NOTIFICATION:
    649                          {
    650                              evt_gatt_attr_notification *evt = (evt_gatt_attr_notification*)blue_evt->data;
    651                              GATT_Notification_CB(evt->attr_handle, evt->event_data_length - 2, evt->attr_value);
    652                          }
    653                          break;
    654                       case EVT_BLUE_L2CAP_CONN_UPD_RESP:
    655                          {
    656                              evt_l2cap_conn_upd_resp *resp = (void*)blue_evt->data;
    657                              if(resp->result){
    658                                  PRINTF("> Connection parameters rejected.\n");
    659                              }
    660                              else{
    661                                  PRINTF("> Connection parameters accepted.\n");
    662                              }
    663                          }
    664                          break;
    665          #ifdef CLIENT            
    666                        case EVT_BLUE_GATT_DISC_READ_CHAR_BY_UUID_RESP:
    667                          {
    668                              evt_gatt_disc_read_char_by_uuid_resp *resp = (void*)blue_evt->data;
    669                              
    670                              if (APP_FLAG(START_READ_TX_CHAR_HANDLE) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    671                              {
    672                                tx_handle = resp->attr_handle;
    673                                PRINTF("TX Char Handle %04X\n\r", tx_handle);
    674                              }
    675                              else if (APP_FLAG(START_READ_RX_CHAR_HANDLE) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    676                              {
    677                                rx_handle = resp->attr_handle;
    678                                PRINTF("RX Char Handle %04X\n\r", rx_handle);
    679                              }
    680                          }
    681                          break;  
    682                          
    683                          case EVT_BLUE_GATT_PROCEDURE_COMPLETE:
    684                          {
    685                            /* Wait for gatt procedure complete event trigger related to Discovery Charac by UUID */
    686                            //evt_gatt_procedure_complete *pr = (void*)blue_evt->data;
    687                            
    688                            if (APP_FLAG(START_READ_TX_CHAR_HANDLE) && !APP_FLAG(END_READ_TX_CHAR_HANDLE))
    689                            {
    690                              APP_FLAG_SET(END_READ_TX_CHAR_HANDLE);
    691                            }
    692                            else if (APP_FLAG(START_READ_RX_CHAR_HANDLE) && !APP_FLAG(END_READ_RX_CHAR_HANDLE))
    693                            {
    694                              APP_FLAG_SET(END_READ_RX_CHAR_HANDLE);
    695                            }
    696                          }
    697                          break;
    698          #endif         
    699                      }
    700                  }
    701                  break;
    702              }
    703              
    704          }
    705          
    706          
    707          #ifdef USE_FULL_ASSERT
    708          /*******************************************************************************
    709          * Function Name  : assert_failed
    710          * Description    : Reports the name of the source file and the source line number
    711          *                  where the assert_param error has occurred.
    712          * Input          : - file: pointer to the source file name
    713          *                  - line: assert_param error line source number
    714          * Output         : None
    715          * Return         : None
    716          *******************************************************************************/
    717          void assert_failed(uint8_t* file, uint32_t line)
    718          {
    719              /* User can add his own implementation to report the file name and line number,
    720              ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    721              
    722              /* Infinite loop */
    723              while (1)
    724              {
    725                printf("\r\nFailed\r\n");
    726                Clock_Wait(10000);
    727              }
    728          }
    729          #endif
    730          
    731          /******************* (C) COPYRIGHT 2014 STMicroelectronics *****END OF FILE****/
    732          /** \endcond
    733           */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   GAP_ConnectionComplete_CB
         0   -> printf
        16   -> printf
        16   -> turnLED
       8   GAP_DisconnectionComplete_CB
         8   -> printf
         8   -> turnLED
       0   GATT_Notification_CB
       8   HCI_Event_CB
         8   -> Attribute_Modified_CB
         0   -> GAP_ConnectionComplete_CB
         0   -> GAP_DisconnectionComplete_CB
         8   -> GPIO_ToggleBits
         0   -> printf
         0   -> startTimer
      56   Make_Connection
        56   -> aci_gap_set_discoverable
        56   -> printf
      64   User_Process
        64   -> aci_gap_set_discoverable
        64   -> printf
      64   main
        64   -> Add_Chat_Service
        64   -> BlueNRG_RST
        64   -> Clock_Init
        64   -> Clock_Wait
        64   -> FLASH_SLEEPPowerDownCmd
        64   -> HCI_Init
        64   -> HCI_Process
        64   -> Init_GPIOs
        64   -> NVIC_PriorityGroupConfig
        64   -> NVIC_SetVectorTable
        64   -> PWR_FastWakeUpCmd
        64   -> PWR_PVDCmd
        64   -> PWR_UltraLowPowerCmd
        64   -> RCC_Configuration
        64   -> SdkEvalGetVersion
        64   -> SdkEvalIdentification
        64   -> SdkEvalSpiInit
        64   -> SdkEval_IO_Config
        64   -> aci_gap_init
        64   -> aci_gap_set_discoverable
        64   -> aci_gatt_init
        64   -> aci_hal_set_tx_power_level
        64   -> aci_hal_write_config_data
        64   -> enableTimerInterrupt
        64   -> initLED
        64   -> initTimer
        64   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       2  ?_0
      28  ?_1
       8  ?_10
       8  ?_11
      16  ?_12
      36  ?_13
      36  ?_14
       8  ?_15
      16  ?_16
      20  ?_2
      20  ?_3
      48  ?_4
      32  ?_5
      32  ?_6
      28  ?_7
       8  ?_8
      24  ?_9
      94  GAP_ConnectionComplete_CB
      78  GAP_DisconnectionComplete_CB
       2  GATT_Notification_CB
     148  HCI_Event_CB
      68  Make_Connection
      84  User_Process
       8  connection_handle
          app_flags
       8  l2cap_req_timer
     378  main

 
     8 bytes in section .bss
     8 bytes in section .data
     2 bytes in section .rodata
 1 240 bytes in section .text
 
 1 240 bytes of CODE  memory
     2 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: 2
